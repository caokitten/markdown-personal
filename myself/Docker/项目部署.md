## mysql部署实现

```powershell
docker run -d \
  --name mysql \
  -p 3307:3306 \
  -e TZ=Asia/Shanghai \
  -e MYSQL_ROOT_PASSWORD=1234 \
  mysql:8
#需提前杀死进程
```

- 自动从镜像仓库搜索并下载mysql的镜像
  - 镜像,即包含mysql本体,以及其运行所需的环境,配置与系统级函数库,使得运行时就有独立的运行环境
  - 容器,即该独立的运行环境,不依赖于主机,因此不需要考虑系统环境问题(**一个镜像可以创建多个独立的容器**)
  - 镜像与容器类似于类与实例关系

- 镜像仓库

  - DockerRedisty(镜像仓库,由官方仓库及第三方仓库)
  - 私有镜像仓库

- Docker服务(Docker Server)

  - Client:

    ```powershell
    docker run ...
    ```

  - Docker Server:守护进程

  - DockerRedisty/私有镜像仓库

  - Docker Server:处理镜像并创建容器,完成部署

- ```powershell
  docker run -d \
    --name mysql \
    -p 3307:3306 \
    -e TZ=Asia/Shanghai \
    -e MYSQL_ROOT_PASSWORD=123 \
    mysql:8
    # docker run [选项] 镜像名 [容器内命令]
    # -d		容器后台运行
    # --name mysql		容器命名
    # -p		端口映射,将宿主机的3307端口映射到容器内的3306端口
    # 容器是隔离环境,外界无法访问,但是可以将宿主机的端口映射到容器内到端口,从而实现外界访问宿主机的3307端口,进而访问容器内设定的3306端口(mysql进程默认3306端口)
    # -e		配置容器内进程运行时的一些参数(-e key=value)
    # TZ=value		设置时区
    # MYSQL_ROOT_PASSWORD=value		设置root用户密码
    # REPOSITORY:TAG(mysql:8)		设置镜像名称,Docker根据该对搜索并下载镜像,TAG未指定则默认为latest
    # -v		指定数据卷(容器内目录位置,宿主机目录固定:/var/lib/docker/volumes/数据卷名字/_data)
  ```

## Docker基础

### 命令

|      命令      | 注解                   |
| :------------: | ---------------------- |
|  docker pull   | 拉取镜像(下载镜像)     |
|  docker push   | 推送镜像至镜像仓库     |
| docker images  | 查看本地镜像           |
|   docker rmi   | 删除本地镜像           |
|   docker run   | 创建权并运行本地容器   |
|  docker stop   | 停止指定容器           |
|  docker start  | 启动指定容器           |
| docker restart | 重启指定容器           |
|   docker rm    | 删除指定容器           |
|   docker ps    | 查看容器               |
|  docker logs   | 查看容器运行日志       |
|  docker exec   | 进入容器               |
|  docker save   | 保存镜像到本地压缩文件 |
|  docker load   | 加载本地压缩文件到镜像 |
| docker inspect | 查看容器详细信息       |

```shell
# 默认情况下,需要手动启动docker及docker容器

# Docker开机自启
systemctl enable docker

# Docker容器开机自启
docker update --restart=always [容器名/容器id]

# 查看容器运行日志
docker logs -f 容器名
```

### 数据卷

由于隔离环境,容器运行时产生的数据存储在容器内部,数据的访问与操作,容器的更新因数据与容器的高耦合性不易进行

因此需要将**数据与容器进行解耦**

- 数据卷是一个虚拟目录,是容器目录与宿主机目录映射的桥梁

- 挂载:将容器目录与宿主机目录关联起来:**容器目录->数据卷->宿主机目录**

- 插入数据卷而非直接将容器目录指向宿主机:**将容器目录与宿主机目录解耦,避免强耦合**

- |         命令          | 注解                 |
  | :-------------------: | -------------------- |
  |  docker volume creat  | 创建数据卷           |
  |   docker volume ls    | 查看所有数据卷       |
  |   docker volume rm    | 删除指定数据卷       |
  | docker volume inspect | 查看某个数据卷的详细 |
  |  docker volume prune  | 删除数据卷           |

- **创建好的容器不能设置数据卷,数据卷只能在创建容器时设置,创建容器时自动创建数据卷**

- 匿名数据卷(未定义的数据卷),使用方式与普通数据卷无差别

- ```shell
  {
    "Config": {
      // ... 略
      "Volumes": {
        "/var/lib/mysql": {} # 没有实现挂载
      }
      // ... 略
    }
  }
  ```

  ```shell
  {
    "Mounts": [
      {
        "Type": "volume",
        "Name": "29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f", # 未声明名字,自动生产一个哈希值作为数据卷名
        "Source": "/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data", # 宿主机目录
        "Destination": "/var/lib/mysql", #容器内目录
        "Driver": "local",
      }
    ]
  }
  ```

- 挂载本地目录或文件

  ```shell
  # 挂载本地目录
  -v 本地目录:容器内目录
  
  # 挂载本地文件
  -v 本地文件:容器内文件
  ```

  本地目录或文件必须以`/`或`./`开头否则会被识别为数据卷名而非本地目录名

### 自定义镜像

#### 镜像结构

镜像文件由按照操作的步骤分层叠加而成,每一层文件都会单独打包并标记一个唯一id,称为Layer(层)

- 入口
- 层
- 基础镜像

#### Dockerfile

在打包的过程中,需要将每一层要做的事情用固定的语法描述下来,交给Docker去执行即可,这种记录镜像结构的文件称为Dockerfile

| **指令**       | **说明**                                     | **示例**                     |
| :------------- | :------------------------------------------- | :--------------------------- |
| **FROM**       | 指定基础镜像                                 | `FROM centos:7`              |
| **ENV**        | 设置环境变量，可在后面指令使用               | `ENV key value`              |
| **COPY**       | 拷贝本地文件到镜像的指定目录                 | `COPY ./xx.jar /tmp/app.jar` |
| **RUN**        | 执行Linux的shell命令，一般是安装过程的命令   | `RUN yum install gcc`        |
| **EXPOSE**     | 指定容器运行时监听的端口，是给镜像使用者看的 | EXPOSE 8080                  |
| **ENTRYPOINT** | 镜像中应用的启动命令，容器运行时调用         | ENTRYPOINT java -jar xx.jar  |

如:

```shell
# 使用 CentOS 7 作为基础镜像
FROM centos:7

# 添加 JDK 到镜像中
COPY jdk17.tar.gz /usr/local/
RUN tar -xzf /usr/local/jdk17.tar.gz -C /usr/local/ &&  rm /usr/local/jdk17.tar.gz

# 设置环境变量
ENV JAVA_HOME=/usr/local/jdk-17.0.10
ENV PATH=$JAVA_HOME/bin:$PATH

# 创建应用目录
RUN mkdir -p /app
WORKDIR /app

# 复制应用 JAR 文件到容器
COPY app.jar app.jar

# 暴露端口
EXPOSE 8080

# 运行命令
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app/app.jar"]

#构筑镜像
docker build -t 镜像名 .
# -t	为镜像取名,格式repository:tag,不指定tag时默认latest
# . 指定Dockerfile所在目录,.表示当前目录
```

#### 网络

容器之间可以相互访问,但容器的网络IP是一个虚拟的IP,其值并不固定

| **命令**                  | **说明**                 |
| :------------------------ | :----------------------- |
| docker network create     | 创建一个网络             |
| docker network ls         | 查看所有网络             |
| docker network rm         | 删除指定网络             |
| docker network prune      | 清除未使用的网络         |
| docker network connect    | 使指定容器连接加入某网络 |
| docker network disconnect | 使指定容器连接离开某网络 |
| docker network inspect    | 查看网络详细信息         |

自定义网络

```shell
# 1.首先通过命令创建一个网络
docker network create itheima

# 2.然后查看网络
docker network ls

# 结果：
NETWORK ID     NAME      DRIVER    SCOPE
639bc44d0a87   bridge    bridge    local
403f16ec62a2   itheima     bridge    local
0dc0f72a0fbb   host      host      local
cd8d3e8df47b   none      null      local
# 其中，除了itheima以外，其它都是默认的网络


# 3.让 myapp 和 mysql 都加入该网络
# 3.1.mysql容器，加入 itheima 网络
docker network connect itheima mysql

# 3.2.myapp容器，也就是我们的java项目, 加入 itheima 网络
docker network connect itheima myapp


# 4.进入dd容器，尝试利用别名访问db
# 4.1.进入容器
docker exec -it myapp bash

# 4.2.用容器名访问
ping mysql

# 结果：
PING mysql (172.18.0.2) 56(84) bytes of data.
64 bytes from mysql.itheima (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms
64 bytes from mysql.itheima (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms
```

## 项目部署

### 后端部署

- 修改application.yml等配置文件

  - 数据库服务器地址:jdbc:mysql://mysql容器名称:容器内部端口/库名,以及用户与用户密码

    容器间若处于同一网络中,可直接通过容器内部端口相互访问,否则通过宿主机端口访问

  - 修改日志文件存放地址

- 测试打包

- 编写Dockerfile文件

  ```shell
  # 使用 CentOS 7 作为基础镜像
  FROM centos:7
  
  # 添加 JDK 到镜像中(需要准备jdk17.tar.gz文件至同一目录下)
  COPY jdk17.tar.gz /usr/local/
  RUN tar -xzf /usr/local/jdk17.tar.gz -C /usr/local/ &&  rm /usr/local/jdk17.tar.gz
  
  # 设置环境变量
  ENV JAVA_HOME=/usr/local/jdk-17.0.10
  ENV PATH=$JAVA_HOME/bin:$PATH
  
  # 阿里云OSS环境变量
  ENV OSS_ACCESS_KEY_ID=LTAI5tP6dc4cvccdvvySE39X
  ENV OSS_ACCESS_KEY_SECRET=ZSyIT31qhxIkS0dH1H9WzHqPiyM3Ot
  
  #统一编码
  ENV LANG=en_US.UTF-8
  ENV LANGUAGE=en_US:en
  ENV LC_ALL=en_US.UTF-8
  
  # 创建应用目录
  RUN mkdir -p /tlias
  WORKDIR /tlias
  
  # 复制应用 JAR 文件到容器
  COPY  tlias.jar  tlias.jar
  
  # 暴露端口
  EXPOSE 8080
  
  # 运行命令
  ENTRYPOINT ["java","-jar","/tlias/tlias.jar"]
  ```

- 将三文件上传至Linux服务器中

  在同一目录中,构建Docker镜像:

  ```shell
  docker build -t tlias:1.0 .
  ```

  Docker容器部署

  ```shell
  docker run -d --name tlias-server --network itheima -p 8080:8080  tlias:1.0
  # --network 加入网络,需要提前建立
  ```

### 前端部署

- 创建映射的目录

  ```shell
  /usr/local/tlias-web/html # html文件夹
  /usr/local/tlias-web/conf/nginx.conf # nginx配置文件
  ```

- 设置目录映射并运行Docker容器

  ```shell
  docker run -d \
  --name nginx-tlias \
  -v /usr/local/tlias-web/html:/usr/share/nginx/html \
  -v /usr/local/tlias-web/conf/nginx.conf:/etc/nginx/nginx.conf \
  --network itheima \
  -p 80:80 \
  nginx:1.20.2
  ```

### DockerCompose

用于实现**多个相互关联的Docker容器的快速部署**

允许用户通过一个单独的docker-compose.yml模板文件来定义一组相互关联的应用容器

使用docker-compose.yml进行部署:

```yml
services:
  mysql:
    image: "nginx:1.20.2"
    container_name: nginx-tlias
    ports:
      - "80:80"
    volumes:
      - "/usr/local/app/html:/usr/share/nginx/html"
      - "/usr/local/app/conf/nginx.conf:/etc/nginx/nginx.conf"
    networks:
      - itheima
networks:
  itheima:
    name: itheima
```

| **docker run 参数** | **docker compose 指令** |
| :------------------ | :---------------------- |
| --name              | container_name          |
| -p                  | ports                   |
| -e                  | environment             |
| -v                  | volumes                 |
| --network           | networks                |

```yml
# mysql docker-compose
services:
  mysql:
    image: mysql:8
    container_name: mysql
    ports:
      - "3307:3306"
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: 123
    volumes:
      - "/usr/local/app/mysql/conf:/etc/mysql/conf.d"
      - "/usr/local/app/mysql/data:/var/lib/mysql"
      - "/usr/local/app/mysql/init:/docker-entrypoint-initdb.d"
    networks:
      - tlias-net
  tlias:
    build: 
      context: .
      dockerfile: Dockerfile
    container_name: tlias-server
    ports:
      - "8080:8080"
    networks:
      - tlias-net
    depends_on:
      - mysql
  nginx:
    image: nginx:1.20.2
    container_name: nginx
    ports:
      - "80:80"
    volumes:
      - "/usr/local/app/nginx/conf/nginx.conf:/etc/nginx/nginx.conf"
      - "/usr/local/app/nginx/html:/usr/share/nginx/html"
    depends_on:
      - tlias
    networks:
      - tlias-net
networks:
  tlias-net:
    name: itheima
```

#### 基础命令

```shell
docker compose [OPTIONS] [COMMAND]
```

| **类型** | **参数或指令** |                           **说明**                           |
| :------: | :------------: | :----------------------------------------------------------: |
| Options  |       -f       |                 指定compose文件的路径和名称                  |
| Options  |       -p       | 指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念 |
| Commands |       up       |                  创建并启动所有service容器                   |
| Commands |      down      |                   停止并移除所有容器、网络                   |
| Commands |       ps       |                      列出所有启动的容器                      |
| Commands |      logs      |                      查看指定容器的日志                      |
| Commands |      stop      |                           停止容器                           |
| Commands |     start      |                           启动容器                           |
| Commands |    restart     |                           重启容器                           |
| Commands |      top       |                        查看运行的进程                        |
| Commands |      exec      |                 在指定的运行中容器中执行命令                 |
